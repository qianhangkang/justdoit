# Java并发面试题

1. synchronized底层如何实现？

   被synchronized修饰的代码块会在代码块的前后加上monitorenter和monitorexit这两个字节码指令，同时这两个字节码指令需要一个引用类型的参数作为加解锁的对象。在执行monitorenter指令时，首先要获取对象的锁，如果这个对象没有被锁定或者当前线程已经拥有了这个对象的锁，那么把锁的计数器+1，对应的，monitorexit会将锁的计数器-1，当计数器为0的时候，锁会被释放。如果获取锁失败，那么这个线程会阻塞等待，直到拿到这个锁为止。

   阻塞一个线程会导致用户态到内核态的转换，这是非常耗时的，因此synchronized是一个重量级的锁，当然虚拟机本身有对此有优化。

2. volatile底层原理？

   - 可见性：被volatile修饰的变量在赋值后会强制将其刷新到主内存中，读取volatile变量也会强制从主内存中读取。
   - 有序性：volatile修饰的变量赋值后虚拟机会为其添加一个lock的空操作，该操作相当于一个内存屏障，下面的指令不允许被重排序到该lock指令之前。该指令也会使本CPU的cache写入内存中，从而引起其他CPU的cache失效。

3. 谈谈JVM是如何进行锁优化的？

   1. 自旋锁和自适应自旋锁

      有时候，共享数据的锁定只是持续了很短的一段时间，为了这段时间去挂起和恢复一个线程显然是不合算的。如果有两个及以上的处理器能够支持多个线程的并行执行，那么可以让后面请求锁的线程稍等一会，而不放弃处理器的执行时间，看持有锁的线程是否很快就会释放锁。

      自适应自旋，自适应意味着自旋的时间不再固定了，它取决于前一次在同一个锁上自旋的时间及锁的拥有者的状态来决定。

   2. 锁消除

      锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

   3. 锁粗化

      如果一系列的连续操作都对同一个对象反复加解锁，虚拟机将会把加锁的范围粗化到整个操作序列之外。

   4. 轻量级锁

      轻量级锁是在无竞争的情况下使用CAS更改对象头中的Mark World为00，消除掉同步使用的互斥量。轻量级锁是为了在线程交替执行同步块时提高性能

   5. 偏向锁

      偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作也不做了，只需要在置换ThreadID的时候依赖一次CAS原子指令。偏向锁则是在只有一个线程执行同步块时进一步提高性能

4. ReentrantLock原理

   底层使用了AQS作为同步器。

   - 支持等待中断
   - 支持公平锁与非公平锁（默认）
   - 支持绑定多个condition来进行await()和signal()操作



   非公平锁获取锁的过程：

   1. 如果当前锁的state为0，那么通过CAS操作来获取当前锁，如果获取成功，将当前线程设置为独占线程
   2. 如果当前锁的state不为0，判断当前线程是否为独占线程，如果是（可重入），那么将state+1
   3. 否则，获取锁失败，返回false
   4. 获取锁失败，则需要创建一个Node节点（包含了线程信息）入队
   5. 挂起线程 `acquireQueued`, 挂起之前，会先尝试获取锁，值有确认失败之后，则挂起锁，并设置前置Node的状态为SIGNAL（以保障在释放锁的时候，可以保证唤醒Node的后驱节点线程）

   公平锁获取锁的过程：

   1. 如果当前锁的state为0，**那么先判断当前线程Node是否有前驱节点，如果没有前驱节点，那么通过CAS操作来获取当前锁，如果有前驱节点那么当前线程放弃获取锁**；如果获取成功，将当前线程设置为独占线程
   2. 如果当前锁的state不为0，判断当前线程是否为独占线程，如果是（可重入），那么将state+1
   3. 否则，获取锁失败，返回false

5. AQS原理

   1. 底层通过CAS操作更新state和插入线程保证操作原子性
   2. 通过CLH同步队列来存储阻塞的线程

6. LinkedBlockingQueue原理

   1. 链表
   2. ReentrantLock（lock和condition）

7. Java线程的6中状态

   1. NEW：新建状态

   2. RUNNABLE：调用线程的start方法后进入的状态，此时线程可能处于“就绪”或者“运行”的状态

   3. BLOCKED：阻塞状态，此时等待monitor锁

   4. WAITING：当线程调用wait，join方法时进入的等待状态

   5. TIMED_WAITING：等待规定的时间的等待状态，如调用Thread.sleep()

   6. TERMINATED：线程执行完成的状态

      ​			**java线程状态转换图**

      ​					NEW

      ​					  ||

      ​					   V

      WAITING   <===>	   RUNNABLE   <===>	TIMED_WAITING

      ​					  		<===>   BLCOKED

      ​					  ||

      ​					   V

      ​				 TERMINATED							

8. 









# 集合类面试题

1. hashmap如何保证初始化容量为2的幂次方？

   将容量最高位后面的位数全置为1然后+1

2. 说一说hashmap的resize()方法？

   resize后一般来说要将hashmap中的元素重新计算hash放置到新的位子上，这样的做法开销很大。jdk8之后，只需要比较hash值多出来的位数是0还是1就可以得到该节点在新的table上的index，这样的做法巧妙的避免了hash值的重新计算，同时新增的1个位可以认为是随机的，这样会将冲突的节点随机的分布到table上

3. hashmap的fail-fast机制？

   fail-fast机制使得集合类在迭代的过程中如果被修改，那么会抛出异常。原理是生成迭代器的时候，集合类会将一个用volatile修饰的modCount传递给迭代器的expectModCount，如果迭代的过程中发现两者不一致，那么就认为该集合被修改了。

4. ConcurrentHashMap如何保证线程安全？

   通过volatile、synchronized和CAS来保证线程安全

5. CopyOnWriteArrayList如何实现线程安全?

   写时复制









# 数据库面试题

1. innoDB和MyISAM区别  

   1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；  

   2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；  

   3. InnoDB是聚集索引，**数据文件是和索引绑在一起的**，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 

   4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；  

   5.  Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；

2. 说一说hash索引和B+树索引

   hash索引采用一定的hash算法，将键值转换成hash值，在查询的时候**尽可能**的直接命中索引

   - hash索引仅仅只能满足等值过滤，对于范围查询无能为力

   - 由于索引的hash值无法保证对应的大小关系，所以hash值无法用来排序运算

   - 遇到大量hash碰撞的情况下，效率可能会大幅度降低

   - Hash 索引在任何时候都不能避免表扫描

   - Hash 索引不支持部分索引查找匹配，即建立一个（a，b）索引，如果只查找列a，那么不会用到索引

   B+树索引采用构造B+树来存储相应的索引信息

   - B+树索引是按顺序存储的，因此可以用作order by或group by，同时支持了范围查询
   - B+树的每个节点大小都是一个页的大小，每个节点只需要一次磁盘IO就能全部加载，同时利用磁盘预读的原理，提高数据查询的命中率

3. 聚集索引和非聚集索引区别

   聚集索引和非聚集索引的**根本区别是表记录的排列顺序和与索引的排列顺序是否一致**，聚集索引表记录的排列顺序与索引的排列顺序一致，优点是查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。 聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，降低了执行速度。建议使用聚集索引的场合为：  **a.此列包含有限数目的不同值； b.查询的结果返回一个区间的值； c.查询的结果返回某值相同的大量结果集。**  非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式。非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组。建议使用非聚集索引的场合为：  **a.此列包含了大量数目不同的值； b.查询的结束返回的是少量的结果集； c.order by 子句中使用了该列。**

4. 查询条件or能不能走索引，说明原因 

   1. 

5. MySQL事务隔离机制？

   - 未提交读

     未提交度可以让事务之间查看到对面未提交的写操作，可能会出现脏读、不可重复读和幻读的问题

   - 已提交读

     当一个事务开始的时候它只能看到已提交事务的修改，这解决了脏读的问题，但是会出现不可重复读和幻读的问题

   - 可重复读

     MySQL默认的事务隔离级别，解决了不可重复读的问题，但是可能会出现幻读，MySQL用**MVCC**解决了

   - 可串行化

     最严格的隔离机制，它强制事务串行执行。但是它会造成频繁的加解锁和锁竞争从而严重影响性能


   **脏读**: 对于两个事务A，B，事务A读取了已经被B更新但还没有提交的字段，之后，若B回滚，T1读取到的内容就是临时无效的内容。

   **不可重复读**: 在事务A中，多次对同一数据进行读取，此时事务B也对该数据进行访问，也许事务B的修改，事务A多次获得的数据可能不一样。

   **幻读**：例如事务A查询id（主键）=1的学生，发现不存在，于是准备插入id=1的学生信息，但是插入之前，事务B先插入了id=1的学生信息，此时事务A插入失败，发生幻读。

   *幻读与不可重复读的区别在于前者侧重 读-写，后者注重 读-读*

6. 什么是MVCC？

   MVCC 是多版本并发控制，innodb通过给每行数据添加三个隐藏的字段来实现

   - 6个字节的事务id
   - 7个字节的回滚指针
   - 6个字节的`DB_ROW_ID`（行id）

   [参考博客](https://segmentfault.com/a/1190000012650596)

7. 





# Spring面试题

1. IOC原理

   IOC（Inversion of controller）是控制反转。通过IOC容器自动管理对象的创建、销毁等过程，目的是为了让对象之间的依赖松耦合。IOC反转的是获得依赖对象的过程，通过DI（Dependency Injection）来注入依赖的对象，DI可以通过构造器、setter方法或者注解来注入依赖的对象。

2. bean的生命周期

   *single类型的bean由beanfactory管理，prototype类型的bean由使用者管理*

   1. 实例化一个bean
   2. 进行IOC注入
   3. 如果这个bean实现了BeanNameAware接口，那么调用接口中的setBeanName(String beanId)方法
   4. 如果这个bean实现了BeanFactoryAware接口，那么调用接口中的setBeanFactory(BeanFactory var1)方法
   5. 如果这个bean实现了ApplicationContextAware接口，那么调用接口中的setApplicationContext(ApplicationContext var1)方法
   6. 如果这个bean实现了BeanPostProcessor接口，那么先调用了接口中的postProcessBeforeInitialization(Object bean, String beanName)方法。该方法在bean初始化之前执行
   7. 如果这个bean实现了InitializingBean接口，那么接着调用afterPropertiesSet()方法
   8. 然后继续调用BeanPostProcessor接口中的postProcessAfterInitialization(Object bean, String beanName)方法。该方法在bean初始化之后执行
   9. 如果这个bean实现了DisposableBean接口，那么bean会调用接口中的destroy()方法，该方法是在bean销毁之前调用

3. beanfactory和applicationcontext是什么关系，使用有什么区别。

   beanfactory是bean的一个工厂，采用工厂模式，提供了最基本的依赖注入的支持，applicationcontext是建立在beanfactory上的，拥有beanfactory的所有功能，同时额外增加了如国际化等支持。

   他们之间最重要的区别是beanfactory加载bean的时候采用的是懒加载，而applicationcontext是在初始化的时候就将所有的bean加载到了内存中，因此可能会消耗大量的内存。

4. aop原理

   aop是面向切面编程，一般用于日志记录、事务管理、权限管理等方面。aop一般通过静态代理和动态代理实现。

   静态代理：一般使用aspectJ。通过编译时生成代理类，再通过代理类回调被代理类中的方法实现。

   动态代理：一般分为两种，一种是JDK动态代理，另一种是cglib代理。

   - jdk动态代理

     jdk动态代理需要被代理类实现接口

   - cglib动态代理

     cglib动态代理是通过继承被代理类实现的

5. Spring的传播机制？

   1. PROPAGATION_REQUIRED，支持当前事务，若没有事务则创建一个。是默认的传播机制
   2. PROPAGATION_SUPPORTS，支持当前事务，若没有事务则按照“非事务”的方式执行
   3. PROPAGATION_MANDATORY，支持当前事务，若没有事务则抛出异常
   4. PROPAGATION_REQUIRES_NEW，创建一个新的事务，如果存在事务则将当前事务挂起
   5. PROPAGATION_NOT_SUPPORTED，不支持当前是事务，总是以“非事务”的方式执行。如果存在事务则将其挂起并且会在合适的时间恢复
   6. PROPAGATION_NEVER，不支持当前事务，若存在事务则抛出异常
   7. PROPAGATION_NESTED，如果当前存在事务，那么执行一个嵌套的事务，否则按照PROPAGATION_REQUIRED机制执行。

6. Spring事务隔离机制？

   1. isolation-default，使用的数据库底层的隔离机制
   2. isolation-read-uncommitted，事务A能够看到事务B未提交的数据
   3. isolation-read-committed，事务A只能看到事务B已经提交的数据，解决了脏读的问题
   4. isolation-repeatable-read，事务A多次读取一个数据都能得到同一个结果，而不会受其他事务修改的影响
   5. isolation-serializable，事务之间串行化执行，避免了脏读、可重复读和幻读的问题，但是会严重影响性能

7. ssm和springbooot有什么区别？

   1. springboot使用“约定大于配置”的方式让spring脱离繁琐的配置
   2. springboot支持java代码来进行配置
   3. springboot提供了一系列starter来简化maven的依赖加载
   4. springboot内置了Tomcat和jetty能够让springboot的应用直接启动

8. springboot如何自定义一个starter？






# 网络原理

1. TCP的三次握手四次挥手

   - 三次握手的原因：防止客户端失效的连接达到服务器让服务器错误的打开连接
   - 四次挥手的原因：让服务器发送完未发送完的数据
   - 四次挥手时客户端等待2MSL的原因：确保客户端发给服务器的最后一个报文能够到达，如果服务器未收到，此时客户端可以重新再发送一个

2. TCP的滑动窗口

   发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

   发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

   接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

3. TCP如何进行拥塞控制

   *拥塞窗口=cwnd，慢开始门限=ssthresh*

   拥塞控制通过四个算法来控制：慢开始、拥塞控制、快重传、快恢复

   - 慢开始：cwnd=1，每次将cwnd加倍直到等于ssthresh

   - 拥塞控制：`cwnd`每次加1，直到出现超时。此时将`ssthresh = cwnd/2`，然后执行慢开始
   - 快重传：发送方如果收到三个重复确认，那么就知道下一个报文丢失了，此时执行快重传，立即重传下一个报文
   - 快恢复：类似慢开始，只不过将cwnd的初始值设置为了`ssthresh`

4. http1.0、http1.1、http2.0

   - http1.0
     1. 每次请求都会建立一个TCP连接
     2. 加入http头的概念
   - Http1.1（广泛采用）
     1. http1.1支持长连接，建立一次TCP连接即可支持多次HTTP通信
     2. 不用等待上次的相应结果就可以再次发出请求
     3. 加入了host字段能够将不同域名映射到同一ip地址上
     4. 支持分块
   - http2.0
     1. http2.0是二进制协议，不是文本协议
     2. 对请求头进行了压缩减少传输成本
     3. 允许服务器向客户端推送消息
     4. 支持多路复用

5. http请求头中keep-alive有什么用

   让客户端到服务器的连接持续有效

6. 






# 分布式

1. CAP理论
   - C：一致性
   - A：可用性
   - P：分区容错性
2. 













# 网上面经

## 有赞

	2 Java的内存分区 

 	3 Java对象的回收方式，回收算法。 

 	4 CMS和G1了解么，CMS解决什么问题，说一下回收的过程。 

 	5 CMS回收停顿了几次，为什么要停顿两次。 

 	6 Java栈什么时候会发生内存溢出，Java堆呢，说一种场景，我说集合类持有对象。 

 	7 那集合类如何解决这个问题呢，我说用软引用和弱引用，那你讲一下这两个引用的区别吧。 

 	8 Java里的锁了解哪些，说了Lock和synchronized 

 	9 它们的使用方式和实现原理有什么区别呢，使用的话，synchronize用于方法和代码块，可以锁对象和类以及方法，Lock一般锁一块代码。并且Lock可以搭配condition使用。 

 	实现原理的话，synchronized使用底层的mutex锁，需要系统调用，而Lock则使用AQS实现。 

 	10 synchronized锁升级的过程，说了偏向锁到轻量级锁再到重量级锁，然后问我它们分别是怎么实现的，解决的是哪些问题，什么时候会发生锁升级。 

 	11Tomcat了解么。说一下类加载器结构吧，我说不知道，说了些别的。 

 	12 问我会什么框架，说了Spring，问我Spring中如何让A和B两个bean按顺序加载，我说依赖关系，他问怎么实现，然后说要用dependon注解，我说不了解。 

 	13 beanfactory和applicationcontext是什么关系，使用有什么区别。 

 	14 MySQL的sql优化了解么，答了解索引优化。  	15 他问我如何做一条sql的优化，说了慢日志和explain。 

 	16 MySQL集群的主从复制怎么做的，具体有哪些线程做哪些事情，使用了哪些日志。 

 	17 CAP定理说一下，为什么三者只能选二，为什么分区容忍性必须保证。 

 	18 平时了解哪些技术是牺牲了一致性来保证可用性的，我说消息队列，他问我MySQL是不是，我说MySQL主从复制应该是。 

 	19 工作中CAP的A和P是怎么选择的，我说选P吧，他的意思是选A。 

 	20 算法题： 

 	一：10亿个数去重，我说用hash分片做，他说可能不均匀，然后我说了bitmap，他说那数字量更多怎么办，我说那就两个bitmap把。他说下一题吧。 

 	二：十亿个数找前10个最大的，小顶堆过一遍即可。他说如果要提高效率呢，我说可以分片做堆排序再进行归并即可。他说OK。



## 网易杭研

 1.手写代码，给个排序数组，可能有重复，找出一个目标值的上界，复杂度限制lgn 

 2.spring中bean的生命周期 

 3.画出TCP三次四次握手状态图，为什么是四次 

 4.如何查看80端口的连接情况,使用什么命令  

5.linux命令知道哪些，软连接和硬连接区别  

6.activeMQ作用 

 7.dubbo相关 

 8.线程池的每个参数含义  

9.数据库三范式  

10.volatile底层原理 

 11.网络七层以及主要的协议      

二面50分钟  

1.http和https的区别，https怎么实现的，一个http请求的执行流程。

  2.线程池参数解释下  

3.innoDB和MyISAM区别  

4.java内存分区以及每个部分什么情况下会溢出  

5.拦截器和过滤器区别

  6.ArrayList不加锁怎么保证线程安全

  7.request和response报文都有哪些内容

  8.给你个sql语句，包括select,where,order by,group by,说一下innoDB底层怎么执行的

  9.where语句写的时候应该注意什么

  10.mybatis怎么把数据库字段和pojo的属性映射起来的

  11.类加载过程和双亲委派  

12.数据库怎么存ip地址，怎么设计索引和算法能准确查找一个ip，并能查询出某个范围的ip。



## 网易考拉

1.同步 异步 非阻塞 阻塞 bio nio aio 

  2.java异常机制类图手写 

  3.spring事务传播机制 

  4.数据库有2000w条记录，复制到另一个服务器内，保证无重复，速度快 

  5.redis事务实现 集群实现 

  6.数据库哈希索引 B+树索引 原理 优缺点实现 

  7.java线程池有哪些参数 分别有什么作用 

  8.重入锁有哪些 底层实现方式 

  9.数据库什么 on where having 区别 没理解明白要问啥 

  10.一个try finally 块返回值是哪个 

  11.值传递 索引传递



## 网易

一面： 

  DEF三个线程在ABC三个线程后运行如何实现 

  消息队列（不会） 

  设计模式，手撕你认为最安全的单例模式 

  数据库索引 

  B+树（画出）说说优点 

  数据库引擎 

  聚集索引和非聚集索引 

  查询条件or能不能走索引，说明原因 

  栅栏和闭锁的区别以及原理 

  synchronized原理 

  AQS原理 

  锁的优化（偏向锁怎么实现） 

  二面 

  大数据处理应该怎么做（根据我项目来的） 

  如何查看索引状态 

  Java异常的继承模型 

  Java线程池 

  场景题：用户连续登陆三天或五天等时，会给用户送积分，问数据库怎么设计以及程序怎么实现



# 网易考拉

一面： 

 	容器方面 

 	1.介绍线程安全的list（copyonwritelist） 

 	2.线程安全的map，具体是怎么实现的，与Hashtable什么区别。 

 	3.CAS 

 	并发 

 	4.知道的线程池（ThreadPoolExecutor属于一类，forkjoin知道吗） 

 	5.线程池怎么自己去实现？给你一个Runnable、一个容器怎么实现。 

 	6.AQS中线程等待怎么做的（线程挂起状态怎么做的）？ 

 	JVM 

 	7.回收算法 

 	8.回收器 

 	9.虚拟机client和server的区别 

 	10.对象和引用之间一般用什么连接？句柄池的作用是什么。 

 	nio、bio 

 	11.阻塞非阻塞的区别？ 

 	12.异步和同步的区别？异步是使用的内核级线程还是用户态线程。 

 	13.AIO在Java中应用到了吗？ 

 	知道那些中间件？redis、rabbitMq、memcached等 

 	redis: 

 	14.redis部署方式。 

 	15.redis怎么加入节点 

 	16.redis持久化。 



 	二面 

 	1.手撕字符串转int 

 	2.数据库事务隔离级别 

 	3.spring 事务 

 	4.数据库索引失效的场景 

 	5.组合索引（A,B）若查询B列是否用到了索引 

 	6.如果A是string类型，而查询的时候是1314151617 用到了索引吗？能查到这条数据吗？ 

 	7.数据库怎么实现乐观锁？ 

 	8.redis pipeline了解吗？ 

 	9.秒杀场景？怎么实现。redis怎么限流，限流算法。 

 	10.redis实现队列、实现优先级队列。 

 	11.分布式锁。 

 	12.TCP流量控制 

 	13.TCP拥塞控制 

 	14.项目问了一些问题。 



## 网易杭研

### 一面

- Java内存模型讲一下 
- GC算法，知道的都讲一下 
- HashMap,get,put实现 
- JsonWebToken具体实现流程（简历） 
- Spring AOP如何实现，写一个AOP功能的主要流程 
- 数据库引擎用过哪些，它们的区别 
- 设计大流量访问系统，要做节流控制（类似秒杀） 
- Linux命令用过哪些 
- 频繁gc排查处理 
- 内存过大排查的处理，用jmap,jstack怎么做，不用又怎么做 
- MySQL主从复制场景问题（bin_log） 
- 项目中技术上最大的成长，项目中的问题解决方案讲一下 

### 二面

- 手撕算法：比如123+234=357，对应两个链表3->2->1，4->3->2（输入），输出结果链表（7->5->3），写一个函数实现，输入为两个链表，输出为一个结果链表。（考虑极端情况和进位情况，花了很久写出来还是不完善） 
- 输入网址到展现发生了什么，越详细越好（我考虑了DNS轮询，负载均衡和CDN以及HTTP状态码，然后就全讲） 
- 负载均衡是怎么做的，CDN具体是怎么实现的 
- TCP三次握手四次挥手 
- cookie和session的区别，多台服务器的情况呢 
- 四次挥手时最后两者的状态，Client的TIME_WAIT避免什么问题，没有它会怎么样 
- SSM和Spring Boot的区别 
- MyBatis和Hibernate区别 
- TCP流量控制和拥塞控制，具体在场景中是怎么起作用的 
- Java线程和OS中的线程的关系，与内存对应关系，一个JVM线程数的上限受哪些因素限制



## 阿里	

 			数据库了解过么？常见的数据库引擎了解吗？ 		

 			InnoDB有什么特点，优点 		

 			索引的原理 		

 			你如何选择索引的字段 		

 			索引的种类，你用过哪些种类的索引？ 		

 			复合索引，最左原则 		

 			用过spring没，spring aop实现原理 		

 			用过spring boot么 		

 			了解过其他AOP包：ASPECTJ么 		

 			JVM内存模型 		

 			OOM与栈溢出异常 		

 			垃圾回收算法 		

 			类加载机制 		

 			线程有哪些状态 		

 			start之后线程就会马上调用吗 		

 			了解过乐观锁和悲观锁么，如何自己实现一个乐观锁 		

 			了解过hashmap与concurrentHashmap源码么 		

 			hashMap高并发下的缺陷？链表为什么会成环？ 		

 			类隔离 		

 			包冲突 		

 			有了解过RPC么 		

​			统计访问最多的IP，用什么排序，分析算法复杂度 		

 			如何实现树的深度搜索，广度搜索（递归，非递归） 		

 			JVM内存模型 		

 			JVM的异常 		

 			HashMap为什么是线程不安全的原因 		

 			并发包，ConcurrentHash底层原理，是怎么做到线程安全的，性能是怎么提升的 		

 			volatile关键词的理解  		

 			TheadLocal的原理 		

 			Spring aop 原理，ASPECTJ 		

 			Spring事务 		

 			数据库InnoDB事务隔离机制 		

 			数据库索引原理 		

 			数据库为什么用B+树 		

 			数据库索引类型 		

 			平时有看过开源框架源码吗 		

 			怎么看待基础知识的学习与框架的学习





## 网易邮件

1、hashmap的原理。         结合着源码blabla，然后包括1.6时Entry，1.8是Node 还有对key的hashcode1.6和1.8用的算法不一样啊之类的blabla，说了一通，什么fail-fast机制啊啥啥啥的。     

 2、哪些方法实现线程安全。         synchronized，reentrantlock，volatile，然后重点说了下volatile在某些情况下可以实现线程安全，然后就把面试官注意力往volatile上引，因为volatile这个专门看了一下，果然，面试官马上问了volatile。         

3、volatile是实现了什么功能呢？         然后就把自己看得乱扯了一通，比如volatile修饰汇编时会在修饰字段前加LOCK字段啊，内存屏障啥啥啥的扯了一通，就是想让面试官觉得对某些方面了解还是蛮深的。         

4、如果想实现一个线程安全的队列，可以怎么实现？         JUC包里的ArrayBlockingQueue 还有LinkedBlockingQueue啥的又结合源码说了一通。         

5、说说http报文的header里面有什么？         WTF!一脸懵逼，没怎么看网络这部分，脑子一片空白，直接说记不清楚了。         

6、给了一个类加载时先后顺序的问题，给了段代码，让你写出输出结果，就静态代码段啊构造函数之类的加载顺序。         这个我也是给跪了，我写对了结果，但是给他解释为什么的时候解释错了，把顺序记反了，还是自己没记清楚。。。         

7、JVM的内存分区         五个分区，然后扯了扯垃圾回收算法，主动扯，然后就被打断了，就说不用说了。         8、数据库的事务管理级别，默认什么级别，会出现哪些问题         四个级别，默认我说是读已提交，但是其实MYSQL的默认应该是可重复读，这个我也是回来才发现的。然后就说了默认读已提交会出现不可重复读和幻读。

